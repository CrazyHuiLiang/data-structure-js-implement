# 绪论

## 计算
计算机只是手段，计算才是目标

计算 = 信息处理

借助某种工具，遵照一定规则，已明确而机械的形式进行

计算模型 = 计算机 = 信息处理工具

所谓算法，即特定计算模型下，旨在解决特定问题的指令序列

输入 待处理的信息
输出 经处理的信息

正确性 的确可以解决指定问题
确定性 任一算法都可以描述为一个由基本操作组成的序列
可行性 每一基本操作都可以实现，且在常数时间内完成
有穷性 对于任何输入，经有穷次基本操作，都可以得到输出

##计算模型

DSA： DataStructure + Algorithm

To measure is to know. If you can not measure it, you can not improve it. -Lord Kelvin

算法分析： 正确性、成本(时间，空间)



O(1): 常数，不含循环，不含分支转向，不含（递归）调用
O(log n): 底数无所谓，常数次幂无所谓，多项式无所谓，复杂度无限接近O(1)
O(n^c): 通常认为已可令人满意。。。（可解，至少还不是难解）
O(2^n): 这类算法的计算成本增长极快，是从有效算法到无效算法的分水岭

##算法分析

两个主要任务 = 正确性（不变性 * 单调性） + 复杂度

C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，两者大体相当
分支转向： goto // 算法的灵魂；出于结构化考虑，被隐藏了
迭代循环： for（）、while（）... // 本质上就是if + goto
调用 + 递归（自我调用） // 本质上也是goto

复杂度分析的主要方法
迭代： 级数求和
递归： 递归跟踪 + 递推方程
猜测 + 验证

算数级数：与末项平方同阶
幂方级数：比幂次高出一阶
几何级数：与末项同阶
收敛级数：O(1)
调和级数：log n
对数级数：n*log n


封底估算（back-of-the-envelope-calculation)
1天 = 24hr * 60min * 60s
    ≈ 25hr * 4000
    = 10^5s

1生 ≈ 1世纪
    = 100yr * 365
    = 3 * 10^4day
    = 3 * 10^9s
    

减而治之：为求解一个大规模的问题，可以将其划分为两个子问题： 其一平凡，另一规模缩减，分别求解子问题，由子问题的解，得到原问题的解。
分而治之：为求解一个大规模的问题，可以将其划分成为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。


