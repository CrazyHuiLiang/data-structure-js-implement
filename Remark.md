# 绪论

## 计算
计算机只是手段，计算才是目标

计算 = 信息处理

借助某种工具，遵照一定规则，已明确而机械的形式进行

计算模型 = 计算机 = 信息处理工具

所谓算法，即特定计算模型下，旨在解决特定问题的指令序列

输入 待处理的信息
输出 经处理的信息

正确性 的确可以解决指定问题
确定性 任一算法都可以描述为一个由基本操作组成的序列
可行性 每一基本操作都可以实现，且在常数时间内完成
有穷性 对于任何输入，经有穷次基本操作，都可以得到输出

##计算模型

DSA： DataStructure + Algorithm

To measure is to know. If you can not measure it, you can not improve it. -Lord Kelvin

算法分析： 正确性、成本(时间，空间)



O(1): 常数，不含循环，不含分支转向，不含（递归）调用
O(log n): 底数无所谓，常数次幂无所谓，多项式无所谓，复杂度无限接近O(1)
O(n^c): 通常认为已可令人满意。。。（可解，至少还不是难解）
O(2^n): 这类算法的计算成本增长极快，是从有效算法到无效算法的分水岭

##算法分析

两个主要任务 = 正确性（不变性 * 单调性） + 复杂度

C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，两者大体相当
分支转向： goto // 算法的灵魂；出于结构化考虑，被隐藏了
迭代循环： for（）、while（）... // 本质上就是if + goto
调用 + 递归（自我调用） // 本质上也是goto

复杂度分析的主要方法
迭代： 级数求和
递归： 递归跟踪 + 递推方程
猜测 + 验证

算数级数：与末项平方同阶
幂方级数：比幂次高出一阶
几何级数：与末项同阶
收敛级数：O(1)
调和级数：log n
对数级数：n*log n


封底估算（back-of-the-envelope-calculation)
1天 = 24hr * 60min * 60s
    ≈ 25hr * 4000
    = 10^5s

1生 ≈ 1世纪
    = 100yr * 365
    = 3 * 10^4day
    = 3 * 10^9s
    

减而治之：为求解一个大规模的问题，可以将其划分为两个子问题： 其一平凡，另一规模缩减，分别求解子问题，由子问题的解，得到原问题的解。
分而治之：为求解一个大规模的问题，可以将其划分成为若干（通常两个）子问题，规模大体相当，分别求解子问题，由子问题的解，得到原问题的解。

##动态规划



#向量

抽象数据类型（ADT） = 数据模型 + 定义在该模型上的一组操作
数据结构 = 基于某种特定语言，实现ADT的一整套算法

向量是数组的抽象与泛化，由一组元素按线性次序封装而成，个元素与[0, n)内的秩（rank）一一对应
元素的类型不限于基本类型（好像是：高级语言中的数组）

1. 构造与析构
    静态空间管理策略
    动态空间管理策略

2. 分摊复杂度
对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作
从实际可行角度，对一系列操作做整体的考量
更加忠实地刻画了可能出现的操作序列
可以更为精准地评判数据结构和算法的真实性能


有序向量查找
大规模： 插值查找
中规模： 折半查找
小规模： 顺序查找


#列表

列表（List）是采用动态存储策略的典型结构，其中的元素称作节点（node）
各节点通过指针或引用彼此联结，在逻辑上构成一个线性序列
前驱或后继若存在，则必然唯一
没有前驱/后继的唯一节点称为首（first/front）/末（last/rear）节点

#栈

典型应用场景

1. 逆序输出conversion：输出次序与处理过程颠倒；递归深度和输出长度不易预知
2. 递归嵌套：具有自相似的问题可递归描述，但分支位置和嵌套深度不固定
3. 延迟缓冲：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀
4. 栈式计算：RPN，基于栈结构的特定计算模式


进制转换： 短除法

#树

无环连通图
极小连通图
极大无环图

任一节点v与根之间存在唯一路径

满二叉树：
真二叉树：每个树的出度必须为偶数（0|2）

先序遍历： V | L | R
中序遍历： L | V | R
后序遍历： L | R | V
层次（广度）: 自上而下，先做后右

#图

无向图：若邻接顶点u和v的次序无所谓，则（u，v）为无向边（undirected edge),所有边均无方向的图，即为无向图（undigraph)
有向图：有向图（digraph）中均为有向边（directed edge）
混合图：图中既有有向边，又有无向边


路径

简单路径：在一条路径中不存在重复节点的路径
环路：路径的起点和终点是重合的


邻接矩阵表示法

广度优先搜索（Breadth-First-Search）： 访问顶点s，依次访问所有尚未访问的邻接顶点，依次访问邻接顶点的尚未访问的邻接顶点
    最短路径：就是广度优先搜索的那条通路的长度
深度优先搜索（Depth-First-Search）：访问顶点，若s尚有未被访问的邻居，则任取其一u，递归执行DFS（u），否则返回
    括号引理：祖先的活跃期是包括后代的活跃期的

#二叉搜索树BST

数据项之间，依照各自的关键码彼此区分（call-by-key）
    条件：关键码之间支持大小比较于相等比对
数据集合中的数据项，统一地表示和实现为词条entry形式

顺序性：任一节点均不小于/不大于其左/右后代
单调性：BST的中序遍历序列，必然单调非降

等价BST：
    上下可变：连接关系不尽相同，承袭关系可能颠倒
    左右不乱：中序遍历序列完全一致，全局单调非降

BBST：平衡二叉搜索树
等价变换 + 旋转调整：
    
